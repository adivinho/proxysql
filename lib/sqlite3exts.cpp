#include <cctype>
#include <cstring>
#include <cstdio>

#include <string>

#include "openssl/err.h"
#include "openssl/sha.h"
#include "openssl/rand.h"

#include "sqlite3ext.h"
SQLITE_EXTENSION_INIT1

using std::string;

char * sha256_crypt_r (const char *key, const char *salt, char *buffer, int buflen);

const uint32_t DEF_SALT_SIZE = 20;

bool check_args_types(int argc, sqlite3_value** argv) {
	bool inv_type = sqlite3_value_type(argv[0]) != SQLITE_TEXT;

	if (inv_type == false && argc == 2) {
		return
			sqlite3_value_type(argv[1]) != SQLITE_TEXT &&
			sqlite3_value_type(argv[1]) != SQLITE_BLOB;
	} else {
		return inv_type;
	}
}

bool check_args_lengths(int argc, sqlite3_value** argv) {
	bool inv_size = true;

	int pass_size = sqlite3_value_bytes(argv[0]);
	if (pass_size > 0) {
		inv_size = false;
	}

	if (inv_size == false && argc == 2) {
		uint32_t salt_size = sqlite3_value_bytes(argv[1]);

		return salt_size <= 0 || salt_size > DEF_SALT_SIZE;
	} else {
		return inv_size;
	}
}


/**
 * @brief SQLite3 extension function for hash generation.
 * @details Computes a hash equivalent to the one generated by MySQL for 'mysql_native_password'.
 * @param context SQLite3 context used for returning computation result.
 * @param argc Number of arguments; expected to be 1.
 * @param argv Argument list; expected to hold one argument with len > 0 of type 'SQLITE_TEXT'.
 */
static void ext_mysql_native_passsword(sqlite3_context* context, int argc, sqlite3_value** argv) {
	if (argc != 1) {
		sqlite3_result_text(context, "Invalid number of arguments", -1, SQLITE_TRANSIENT);
		return;
	} else {
		if (check_args_types(argc, argv)) {
			sqlite3_result_text(context, "Invalid argument type", -1, SQLITE_TRANSIENT);
			return;
		}
		if (check_args_lengths(argc, argv)) {
			sqlite3_result_text(context, "Invalid argument size", -1, SQLITE_TRANSIENT);
			return;
		}
	}

	const unsigned char* input = sqlite3_value_text(argv[0]);
	int input_len = strlen((const char*)input);

	unsigned char hash1[SHA_DIGEST_LENGTH] = { 0 };
	unsigned char hash2[SHA_DIGEST_LENGTH] = { 0 };

	SHA1(input, input_len, hash1);
	SHA1(hash1, SHA_DIGEST_LENGTH, hash2);

	char hex_hash[2 * SHA_DIGEST_LENGTH + 2];

	for (int i = 0; i < SHA_DIGEST_LENGTH; i++) {
		sprintf(hex_hash + 2 * i + 1, "%02x", hash2[i]);

		hex_hash[2 * i + 1] = std::toupper(hex_hash[2 * i + 1]);
		hex_hash[2 * i + 1 + 1] = std::toupper(hex_hash[2 * i + 1 + 1]);
	}

	hex_hash[0] = '*';
	hex_hash[2 * SHA_DIGEST_LENGTH + 1] = '\0';

	sqlite3_result_text(context, hex_hash, -1, SQLITE_TRANSIENT);
}

/**
 * @brief SQLite3 extension function for hash generation.
 * @details Computes a hash equivalent to the one generated by MySQL for 'caching_sha2_password'.
 * @param context SQLite3 context used for returning computation result.
 * @param argc Number of arguments; either 1 or 2. One for random salt, two providing salt.
 * @param argv Argument list; expected to hold either 1 or 2 arguments:
 *   1. Password to be hashed; with len > 0 and of type 'SQLITE_TEXT'.
 *   1. Optional salt; with (len > 0 && len <= 20) and of type ('SQLITE_TEXT' || 'SQLITE_BLOB'). If no salt is
 *      provided a randomly generated salt with length 20 will be used.
 */
static void ext_caching_sha2_password(sqlite3_context* context, int argc, sqlite3_value** argv) {
	if (argc < 1 || argc > 2) {
		sqlite3_result_text(context, "Invalid number of arguments", -1, SQLITE_TRANSIENT);
		return;
	} else {
		if (check_args_types(argc, argv)) {
			sqlite3_result_text(context, "Invalid argument type", -1, SQLITE_TRANSIENT);
			return;
		}
		if (check_args_lengths(argc, argv)) {
			sqlite3_result_text(context, "Invalid argument size", -1, SQLITE_TRANSIENT);
			return;
		}
	}

	uint32_t salt_size = DEF_SALT_SIZE;
	const char* cpass = reinterpret_cast<const char*>(sqlite3_value_text(argv[0]));
	string salt {};

	if (argc == 2) {
		salt_size = sqlite3_value_bytes(argv[1]);
		const char* b_salt = reinterpret_cast<const char*>(sqlite3_value_blob(argv[1]));

		salt = string(b_salt, salt_size);
	} else {
		unsigned char salt_buf[DEF_SALT_SIZE + 1] = { 0 };

		if (RAND_bytes(salt_buf, DEF_SALT_SIZE) != 1) {
			char err_buf[256] = { 0 };

			const unsigned long err = ERR_get_error();
			ERR_error_string(err, err_buf);

			const string err_msg {
				"SALT creation failed '" + std::to_string(err) + "':'" + string { err_buf } + "'"
			};

			sqlite3_result_text(context, err_msg.c_str(), -1, SQLITE_TRANSIENT);
			return;
		} else {
			for (uint32_t i = 0; i < sizeof(salt_buf)/sizeof(unsigned char); i++) {
				salt_buf[i] = salt_buf[i] & 0x7f;

				if (salt_buf[i] == '\0' || salt_buf[i] == '$') {
					salt_buf[i] = salt_buf[i] + 1;
				}
			}

			salt = string(reinterpret_cast<char*>(salt_buf), DEF_SALT_SIZE);
		}
	}

	const string base_sha2_salt { "$5$rounds=5000$" };
	const string base_sha2_hash { "$A$005$" };

	char sha2_buf[100] = { 0 };
	string sha2_salt { "$5$rounds=5000$" + salt };

	sha256_crypt_r(cpass, sha2_salt.c_str(), sha2_buf, sizeof(sha2_buf));

	const string sha256(sha2_buf + salt_size + base_sha2_salt.size() + 1);
	const string sha2_hash { "$A$005$" + salt + sha256 };

	sqlite3_result_text(context, sha2_hash.c_str(), -1, SQLITE_TRANSIENT);
}

int sqlite3_extensions_init(sqlite3 *db, char** errmsg, const sqlite3_api_routines* api) {
	SQLITE_EXTENSION_INIT2(api)

	int rc = sqlite3_create_function(
		db, "MYSQL_NATIVE_PASSWORD", 1, SQLITE_UTF8 | SQLITE_DETERMINISTIC, NULL, ext_mysql_native_passsword, NULL, NULL
	);
	if (rc != SQLITE_OK) {
		*errmsg = sqlite3_mprintf("Failed to create sha1_of_sha1 function: %s", sqlite3_errmsg(db));
		return rc;
	}

	// Register twice; One argument for non-user provided salt
	rc = sqlite3_create_function(
		db, "CACHING_SHA2_PASSWORD", 1, SQLITE_UTF8 | SQLITE_DETERMINISTIC, NULL, ext_caching_sha2_password, NULL, NULL
	);
	if (rc != SQLITE_OK) {
		*errmsg = sqlite3_mprintf("Failed to create sha1_of_sha1 function: %s", sqlite3_errmsg(db));
		return rc;
	}

	// Register twice; Second argument for user provided salt
	rc = sqlite3_create_function(
		db, "CACHING_SHA2_PASSWORD", 2, SQLITE_UTF8 | SQLITE_DETERMINISTIC, NULL, ext_caching_sha2_password, NULL, NULL
	);
	if (rc != SQLITE_OK) {
		*errmsg = sqlite3_mprintf("Failed to create sha1_of_sha1 function: %s", sqlite3_errmsg(db));
		return rc;
	}

	return SQLITE_OK;
}
